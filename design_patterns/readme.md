## Паттерны проектирования.

Лекции по книги Head First "Паттерны проектирования".

### Паттерн - решение задачи в контексте.
- Контекстом называется ситуация, в которой применяется паттерн. Ситуация должна быть достаточно типичной и распространенной.
- Задачей называется цель, которой вы хотите добиться в контексте, в совокупности со всеми ограничениями, присущими контексту.
- Решением называется обобщенная архитектура, которая достигает заданной цели при соблюдении набора ограничений.

Наличие формального механизма описания позволяет создавать чрезвычайно полезные каталоги паттернов.

### Классификация паттернов проектирования в зависимости от их цели:
- Порождающие - связаны с созданием экземпляров объектов; все они обеспечивают средства логической изоляции клиента от создаваемых объектов;
- Поведенческие - относятся к взаимодействиям и распределению обязанностей между классами и объектами;
- Структурные - объединяют классы или объекты в более крупные структуры.


### Классификация паттернов проектирования в зависимости от того, относится паттерн к классам или объектам:
- Паттерны классов - описывают определение отношений между классами посредством наследования (Шаблонный метод, адаптер, Фабричный метод, Интерпретатор);
- Паттерны объектов - описывают отношения между объектами, прежде всего относящиеся к композиции. Отношения в паттернах
объектов обычно определяются на стадии выполнения, а следовательно, обладают большей динамичностью и гибкостью.



1. [Стратегия (Strategy)](Strategy/readme.md)
2. [Наблюдатель (Observer)](Observer/readme.md)
3. [Декоратор (Decorator)](Decorator/readme.md)
4. [Фабричный метод (Factory Method)](FactoryMethod/readme.md)
5. [Абстрактная фабрика(Abstract Factory)](AbstractFactory/readme.md)
6. [Одиночка (Singleton)](Singleton/readme.md)
7. [Команда (Command)](Command/readme.md)
8. [Адаптер (Adapter)](Adapter/readme.md)
9. [Шаблонный метод (Template Method)](TemplateMethod/readme.md)
10. [Итератор (Iterator)](Iterator/readme.md)
11. [Компоновщик (Composite)](Composite/readme.md)
12. [Состояние (State)](State/readme.md)
13. [Заместитель (Proxy)](Proxy/readme.md)

// TODO Необходимо дополнить примерами
14. [Мост (Bridge)](Bridge/readme.md)
15. [Строитель (Builder)](Builder/readme.md)
16. [Цепочка обязанностей (Chain of Responsibility)](ChainOfResponsibility/readme.md)

17. Приспособленец (Flyweight)
18. Интерпретатор (Interpreter)
19. Посредник (Mediator)
20. Хранитель (Memento)
21. Прототип (Prototype)
22. Посетитель (Visitor)
23. Фасад (Facade)


#### Принципы:
- Инкапсулируйте то, что изменяется;
- Отдавайте предпочтение композиции перед наследованием;
- Программируйте на уровне интерфейсов, а не реализации;
- Стремитесь к слабой связанности взаимодействующих объектов;
- Классы должны быть открыты для расширения, но закрыты для изменения;
- Код должен зависеть от абстракций, а не от конкретных классов (принцип инверсии зависимостей);
- Принцип минимальной информированности: общайтесь только с близкими друзьями (при проектировании системы
  для любого объекта следует обратить особое внимание на количество классов, с которыми он взаимодействует).
  Также называют законом Деметры;
- Голливудский принцип: Не вызывайте нас - мы вас сами вызовем. Помогает предотвратить явление когда компоненты
  высокого уровня зависят от компонентов низкого уровня, которые зависят от компонентов низкого уровня, и т.д;
- Принцип одной обязанности. Класс должен иметь только одну причину для изменения (каждая обязанность класса
  является областью потенциальных изменений, несколько обязанностей - несколько причин для изменений);