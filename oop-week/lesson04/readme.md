## Урок 4. Как пишутся хорошие программы

Рассказывает про namespace и автозагрузку spl_autoload_register.

Принципы разбиения системы на модули и принципы организации модулей.

- Какие принципы проектирования существуют
- Какие качества в себе нужно воспитать
- Так ли это всё в реальной жизни

___
Для чего придумали ООП? Для упрощения сложности и для дополнительного уровня абстракции.
___

### Пример с корзиной интернет магазина

[Как бы это было без ООП](./example01/demo01/CartController.php)

Чем это хорошо?
- Такой код пишется быстро.

Чем это плохо?
- Низкоуровневый код, т.к. напрямую работает с session (если нужно будет работать с cookies, то придется везде переписать);
- Тестировать тяжело. Много действий в контроллере: получить, проверить и редирект;
- Если понадобится в другом контроллере добавить корзину, то придется копипастить код.

По MVC это тоже неправильно, т.к. контроллер должен быть тонким (получить параметры и вызвать нужный код), не делать все это сам.

Лапшекод в контроллере можно побороть созданием любого специализированного компонента и инкапсулировать в него
всю логику.

[Логика из методов контроллера вынесена в компонент Cart](./example01/demo02/CartController.php)

Пришли к тому, что сейчас методы контроллера тонкие и их не нужно тестировать. Достаточно протестировать 
сам компонент cart. В консоли `./vendor/bin/phpunit`.

[Логика компонента Cart](./example01/demo03/cart/Cart.php)

Получилась примитивная корзина с работой с сессией. Но что если сессия будет храниться в БД?
В таком случае напрямую работать с $_SESSION нельзя, нужно будет абстрагироваться.

Также нужно вынести повторяющиеся части кода.

Перед тем как выносить повторяющиеся части кода в отдельные методы, нужно написать unit-тесты. 
Подключение через composer.

[Тесты для компонента Cart](./example01/demo04/tests/CartTest.php)

[Повторяющиеся части вынесены](./example01/demo04/cart/Cart.php)

Плюсом является то, что если дергать методы компонента Cart, то данные из сессии будут загружены только 1 раз.

Но этот код негибкий.
Чтобы это было гибче, можно от компонента Cart наследоваться и переопределять методы load и save.

[Например, для Yii2](./example01/demo04/cart/YiiCart.php)

[Или для Symfony](./example01/demo04/cart/SymfonyCart.php)


А что если задача будет стоять так: для авторизованных пользователей данные хранятся в БД, для не 
авторизованных - в cookies?

[В таком случае могло бы быть так для Yii2](./example01/demo04/cart/YiiHybridCart.php)

[Для Symfony](./example01/demo04/cart/SymfonyHybridCart.php)

Такой подход, когда мы выделяем какой-нибудь метод и разрешаем его переопределять при наследовании называется 
паттерном `Шаблонный метод`.


Допустим, сейчас нужно еще считать стоимость товаров в корзине. Для этого первоначальный массив не подходит.

[Можно сделать вспомогательный объект (структуру) именно для хранения элемента товара](./example01/demo05/cart/CartItem.php)

CartItem - не DTO, он объект-значение.

В корзине появилось два участка кода, которые могут изменяться со временем:
- сохранение в БД, сессии;
- подсчет стоимости товаров с учетом скидок.

Теперь в одном классе сошлись 4 вещи:
- сами алгоритмы корзины, которые добавляют/удаляют элементы;
- хранилище save и load;
- проверка на залогинен пользователь или нет;
- может меняться подсчет стоимости.

Чтобы сделать корзину чистой, можно изменяемые вещи вынести в отдельные компоненты.
При таком подходе можно будет избежать наследования.

Хранилище будет вынесено в отдельный компонент.

Для этого создали интерфейс StorageInterface, реализованы методы load и save.
Созданы несколько видов хранилища: SessionStorage, YiiSessionStorage, YiiDbStorage, YiiHybridStorage.
В конструктор класса Cart нужно передать требуемый объект $storage.

[Теперь нужно создать требуемое хранилище и передавать его в объект Cart](./example01/demo06/index.php)

Теперь из корзины вынесена логика сохранения в хранилище.
Осталось вынести подсчет стоимости в отдельный компонент.
Потому что возможны любые формулы для подсчета стоимости (др, залогинен и т.д.).
Если все это делать в методе getCost(), то тесты сломаются, точнее куча тестов на один метод чтоб все учесть.

Чтоб этого избежать, небоходимо создать интерфейс 
[CalculationInterface с методом getCost()](./example01/demo07/cart/cost/CalculatorInterface.php),
а в конструктор компонента [Cart](./example01/demo07/cart/Cart.php) передавать объект реализующий этот интерфейс.

И теперь можно создать кучу классов для подсчета скидки, можно даже 
[реализовать цепочку вызовов](./example01/demo07/cart/cost/BirthdayCost.php), чтобы применять несколько скидок.

Теперь достаточно для каждого класса реализующего интерфейс CalculationInterface написать тест. Так как некотороые
объекты требуют в конструкторе объект этого интерфейса (цепочка вызовов), то можно создать тестовый класс
DummyCost и передавать его.

___

### Во втором примере будет расмотрено как спрограммированную корзину подключать к разным вещам.

[Самый простой способ использования](./example02/demo01/index.php)

Но если нужно будет писать этот в код в нескольких местах, то:
- неудобно создавать;
- если нужно будет один и тот же экземпляр корзины (хотя из сессий и БД все равно будут одни и те же данные).

Можно сделать singleton, но тогда возникнут проблемы при тестировании, потому что один и тот же объект будет возвращать.

[Можно создать контейнер](./example02/demo02/index.php)

Это позволит создавать компоненты "на лету" тогда, когда они нужны.
Метод set зарегистрирует анонимную функцию (создания нужного объекта).
Метод get вызывает анонимную функцию (создает нужный объект и возвращает его).

Такой подход позволит регистрировать хоть сколько компонентов под разными именами передавая только функции, которые их
будет создавать, вместо того чтобы сразу их создавать.

Этот код можно вынести куда-нибудь в конфигурационный файл:
```php
$container = new Container();
$container->set('cart.storage', function (Container $container) {
    return new SessionStorage('cart');
});
$container->set('cart.calculator', function (Container $container) {
    return new SimpleCost();
});
$container->set('cart', function (Container $container) {
    return new Cart(
        $container->get('cart.storage'),
        $container->get('cart.calculator')
    );
});
```

А в контроллере вызывать только:
```php
$cart = $container->get('cart');
```

Но сейчас проблема в том, что при каждом вызове создается новый экземпляр класса Cart. А нужно чтоб новый объект
создавался только при первом вызове, а последующие возвращали уже созданный экземпляр.

[Добавлена проверка, создан экземпляр или нет](./example02/demo03/index.php)

Теперь два варианта вписывания регистрации компонентов:
- через метод set. В этом случае компонент будет создаваться каждый раз при вызове;
- через метод setShared. Компонент создастся только один раз и дальше будет возвращаться тот же самый.

Вместо задания компонентов под некими именами можно автоматизировать.

[Получился контейнер, который умеет парсить конструкторы всех классов](./example02/demo04/Container.php)

По сути, что сейчас происходит. Корзина зависит от нескольких зависимостей. С помощью контейнера мы берем корзину
создаем все зависимости, которые ей нужны (хранилище, калькулятор) и через конструктор иньектим в эту корзину.
То есть это dependency injection container, который хранит настройки всех вещей и автоматически иньектит все в друг-друга, 
и возвращает готовый компонент.

[А есть ли готовая библиотека?](https://github.com/ziadoz/awesome-php#dependency-injection)

Рассмотрение версий Pimple 1-й и 3-й версии (то что сначала все было динамически (создание каждый раз),
а теперь все хранится в одном экземпляре).

[Рассмотрен контейнера Yii2](./example02/demo05/index.php)

[Рассмотрен контейнер Symfony](./example02/demo06/index.php). Второй вариант - зависимости в yml файле.

___

### Как теперь корзину привязать к контроллеру?

```php
class CartController
{
    public function actionIndex()
    {
        $cart = new Cart(new SessionStorage('cart'), new SimpleCost());
        return $cart->getItems();
    }

    public function actionAdd($id, $count, $price)
    {
        $cart = new Cart(new SessionStorage('cart'), new SimpleCost());
        $cart->add($id, $count, $price);
        return 'OK';
    }
} 
```

```php
class CartController extends Controller
{
    public function actionIndex()
    {
        $cart = $this->container->get('cart');
        return $cart->getItems();
    }

    public function actionAdd($id, $count, $price)
    {
        $cart = $this->container->get('cart');
        $cart->add($id, $count, $price);
        return 'OK';
    }
}
```

```php
class CartController extends Controller
{
    public function actionIndex()
    {
        $cart = Yii::createObject('lesson04\example04\cart\Cart');
        return $cart->getItems();
    }

    public function actionAdd($id, $count, $price)
    {
        $cart = Yii::createObject('lesson04\example04\cart\Cart');
        $cart->add($id, $count, $price);
        return 'OK';
    }
}
```

```php
class CartController extends Controller
{
    private $cart;

    public function __construct($id, $module, Cart $cart, $config = [])
    {
        $this->cart = $cart;
        parent::__construct($id, $module, $config);
    }

    public function actionIndex()
    {
        return $this->cart->getItems();
    }

    public function actionAdd($id, $count, $price)
    {
        $this->cart->add($id, $count, $price);
        return 'OK';
    }
}
```
___

Итого у нас лёгкость модификации, повторного использования в других проектах (без переписывания), тестирования,
написания и чтения. Какими методами мы добились?
- Разделили код на универсальный и изменчивый
- Инкапсулировали изменчивость
- Разделили код по логическим обязанностям. Корзина ведёт элементы, их сохраняет и подсчитывает.
- Разбили по обязанностям на корзину, хранилище и калькулятор.
- Определили интерфейсы для изменчивых реализаций и переключились на них.
___

___
### SOLID

#### Single responsibility principle SRP (Принцип единственной обязанности)
Класс должен иметь только одну причину для изменения.
#### Open/closed principle (Принцип открытости/закрытости)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации.»
#### Liskov substitution principle (Принцип подстановки Барбары Лисков)
«Объекты должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»
#### Interface segregation principle (Принцип разделения интерфейса)
«Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
#### Dependency inversion principle (Принцип инверсии зависимостей)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
