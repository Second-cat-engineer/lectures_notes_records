## Урок 4. Как пишутся хорошие программы

Рассказывает про namespace и автозагрузку spl_autoload_register.

Принципы разбиения системы на модули и принципы организации модулей.

- Какие принципы проектирования существуют
- Какие качества в себе нужно воспитать
- Так ли это всё в реальной жизни

___
Для чего придумали ООП? Для упрощения сложности и для дополнительного уровня абстракции.
___


Итого у нас лёгкость модификации, повторного использования в других проектах (без переписывания), тестирования,
написания и чтения. Какими методами мы добились?
- Разделили код на универсальный и изменчивый
- Инкапсулировали изменчивость
- Разделили код по логическим обязанностям. Корзина ведёт элементы, их сохраняет и подсчитывает.
- Разбили по обязанностям на корзину, хранилище и калькулятор.
- Определили интерфейсы для изменчивых реализаций и переключились на них.
___

### Пример с корзиной интернет магазина

[Как бы это было без ООП](./example01/demo01/CartController.php)

Чем это хорошо?
- Такой код пишется быстро.

Чем это плохо?
- Низкоуровневый код, т.к. напрямую работает с session (если нужно будет работать с cookies, то придется везде переписать);
- Тестировать тяжело. Много действий в контроллере: получить, проверить и редирект;
- Если понадобится в другом контроллере добавить корзину, то придется копипастить код.

По MVC это тоже неправильно, т.к. контроллер должен быть тонким (получить параметры и вызвать нужный код), не делать все это сам.

Лапшекод в контроллере можно побороть созданием любого специализированного компонента и инкапсулировать в него
всю логику.

[Логика из методов контроллера вынесена в компонент Cart](./example01/demo02/CartController.php)

Пришли к тому, что сейчас методы контроллера тонкие и их не нужно тестировать. Достаточно протестировать 
сам компонент cart. В консоли `./vendor/bin/phpunit`.

[Логика компонента Cart](./example01/demo03/cart/Cart.php)

Получилась примитивная корзина с работой с сессией. Но что если сессия будет храниться в БД?
В таком случае напрямую работать с $_SESSION нельзя, нужно будет абстрагироваться.

Также нужно вынести повторяющиеся части кода.

Перед тем как выносить повторяющиеся части кода в отдельные методы, нужно написать unit-тесты. 
Подключение через composer.

[Тесты для компонента Cart](./example01/demo04/tests/CartTest.php)

[Повторяющиеся части вынесены](./example01/demo04/cart/Cart.php)

Плюсом является то, что если дергать методы компонента Cart, то данные из сессии будут загружены только 1 раз.

Но этот код негибкий.
Чтобы это было гибче, можно от компонента Cart наследоваться и переопределять методы load и save.

[Например, для Yii2](./example01/demo04/cart/YiiCart.php)

[Или для Symfony](./example01/demo04/cart/SymfonyCart.php)


А что если задача будет стоять так: для авторизованных пользователей данные хранятся в БД, для не 
авторизованных - в cookies?

[В таком случае могло бы быть так для Yii2](./example01/demo04/cart/YiiHybridCart.php)

[Для Symfony](./example01/demo04/cart/SymfonyHybridCart.php)

Такой подход, когда мы выделяем какой-нибудь метод и разрешаем его переопределять при наследовании называется 
паттерном `Шаблонный метод`.


Допустим, сейчас нужно еще считать стоимость товаров в корзине. Для этого первоначальный массив не подходит.

[Можно сделать вспомогательный объект (структуру) именно для хранения элемента товара](./example01/demo05/cart/CartItem.php)

CartItem - не DTO, он объект-значение.

В корзине появилось два участка кода, которые могут изменяться со временем:
- сохранение в БД, сессии;
- подсчет стоимости товаров с учетом скидок.

Теперь в одном классе сошлись 4 вещи:
- сами алгоритмы корзины, которые добавляют/удаляют элементы;
- хранилище save и load;
- проверка на залогинен пользователь или нет;
- может меняться подсчет стоимости.

Чтобы сделать корзину чистой, можно изменяемые вещи вынести в отдельные компоненты.
При таком подходе можно будет избежать наследования.

Хранилище будет вынесено в отдельный компонент.

Для этого создали интерфейс StorageInterface, реализованы методы load и save.
Созданы несколько видов хранилища: SessionStorage, YiiSessionStorage, YiiDbStorage, YiiHybridStorage.
В конструктор класса Cart нужно передать требуемый объект $storage.

[Теперь нужно создать требуемое хранилище и передавать его в объект Cart](./example01/demo06/index.php)

Теперь из корзины вынесена логика сохранения в хранилище.
Осталось вынести подсчет стоимости в отдельный компонент.
Потому что возможны любые формулы для подсчета стоимости (др, залогинен и т.д.).
Если все это делать в методе getCost(), то тесты сломаются, точнее куча тестов на один метод чтоб все учесть.

Чтоб этого избежать, небоходимо создать интерфейс 
[CalculationInterface с методом getCost()](./example01/demo07/cart/cost/CalculatorInterface.php),
а в конструктор компонента [Cart](./example01/demo07/cart/Cart.php) передавать объект реализующий этот интерфейс.

И теперь можно создать кучу классов для подсчета скидки, можно даже 
[реализовать цепочку вызовов](./example01/demo07/cart/cost/BirthdayCost.php), чтобы применять несколько скидок.

Теперь достаточно для каждого класса реализующего интерфейс CalculationInterface написать тест. Так как некотороые
объекты требуют в конструкторе объект этого интерфейса (цепочка вызовов), то можно создать тестовый класс
DummyCost и передавать его.

___

### Во втором примере будет расмотрено как спрограммированную корзину подключать к разным вещам.

[Самый простой способ использования](./example02/demo01/index.php)

Но если нужно будет писать этот в код в нескольких местах, то:
- неудобно создавать;
- если нужно будет один и тот же экземпляр корзины (хотя из сессий и БД все равно будут одни и те же данные).

Можно сделать singleton, но тогда возникнут проблемы при тестировании, потому что один и тот же объект будет возвращать.

[Можно создать контейнер](./example02/demo02/index.php)



___
### SOLID

#### Single responsibility principle SRP (Принцип единственной обязанности)
Класс должен иметь только одну причину для изменения.
#### Open/closed principle (Принцип открытости/закрытости)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации.»
#### Liskov substitution principle (Принцип подстановки Барбары Лисков)
«Объекты должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»
#### Interface segregation principle (Принцип разделения интерфейса)
«Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
#### Dependency inversion principle (Принцип инверсии зависимостей)
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
