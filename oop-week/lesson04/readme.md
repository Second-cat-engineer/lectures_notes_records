## Урок 4. Как пишутся хорошие программы

Рассказывает про namespace и автозагрузку spl_autoload_register.

Принципы разбиения системы на модули и принципы организации модулей.

- Какие принципы проектирования существуют
- Какие качества в себе нужно воспитать
- Так ли это всё в реальной жизни

___
Для чего придумали ООП? Для упрощения сложности и для дополнительного уровня абстракции.
___


Итого у нас лёгкость модификации, повторного использования в других проектах (без переписывания), тестирования,
написания и чтения. Какими методами мы добились?
- Разделили код на универсальный и изменчивый
- Инкапсулировали изменчивость
- Разделили код по логическим обязанностям. Корзина ведёт элементы, их сохраняет и подсчитывает.
- Разбили по обязанностям на корзину, хранилище и калькулятор.
- Определили интерфейсы для изменчивых реализаций и переключились на них.
___

### Пример с корзиной интернет магазина

[Как бы это было без ООП](./example01/demo01/CartController.php)

Чем это хорошо?
- Такой код пишется быстро.

Чем это плохо?
- Низкоуровневый код, т.к. напрямую работает с session (если нужно будет работать с cookies, то придется везде переписать);
- Тестировать тяжело. Много действий в контроллере: получить, проверить и редирект;
- Если понадобится в другом контроллере добавить корзину, то придется копипастить код.

По MVC это тоже неправильно, т.к. контроллер должен быть тонким (получить параметры и вызвать нужный код), не делать все это сам.

Лапшекод в контроллере можно побороть созданием любого специализированного компонента и инкапсулировать в него
всю логику.

[Логика из методов контроллера вынесена в компонент Cart](./example01/demo02/CartController.php)

Пришли к тому, что сейчас методы контроллера тонкие и их не нужно тестировать. Достаточно протестировать сам компонент cart.

[Логика компонента Cart](./example01/demo03/cart/Cart.php)

Получилась примитивная корзина с работой с сессией. Но что если сессия будет храниться в БД?






___
### SOLID

#### Single responsibility principle SRP (Принцип единственной обязанности)
Класс должен иметь только одну причину для изменения.
#### Open/closed principle (Принцип открытости/закрытости)
«Программные сущности должны быть открыты для расширения, но закрыты для модификации.»
#### Liskov substitution principle (Принцип подстановки Барбары Лисков)
«Объекты должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»
#### Interface segregation principle (Принцип разделения интерфейса)
«Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
#### Dependency inversion principle
Принцип инверсии зависимостей
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»